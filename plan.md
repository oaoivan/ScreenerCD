# План работ

## Задача: миграция загрузки тикеров CEX-коннекторов на конфигурацию YAML *(статус: выполнено)*

1. **Схема конфигурации**
   - Добавить в `configs/screener-core.yaml` описание бирж с полями `name`, `symbols`, `symbols_file`.
   - Сохранить обратную совместимость через глобальный список `exchanges` и общий JSON.

2. **Парсинг конфигурации**
   - Расширить `internal/config/config.go`, чтобы читать новый блок бирж и выдавать структуру `ExchangeConfig`.
   - Обработать приоритеты: сначала `symbols`, потом `symbols_file`, дальше fallback на общий JSON.

3. **Использование в сервисах**
   - Обновить `cmd/screener-core/main.go`: формировать набор тикеров для каждой биржи на основе конфигурации.
   - Обновить `cmd/api-gateway/main.go`: использовать те же правила загрузки тикеров. *(историческая задача, сервис позже удалён)*
   - Вести подробный лог выбранных источников.

4. **Чистка прямых ссылок**
   - Найти оставшиеся обращения к `Temp/all_contracts_merged_reformatted.json` в core/gateway и заменить на новый механизм или отметить как утилитарные.

5. **Проверка**
   - Выполнить `go build ./cmd/screener-core` и `go build ./cmd/api-gateway`. *(актуально на этапе миграции; после удаления API Gateway не требуется)*
   - Зафиксировать результат и необходимые дальнейшие шаги. *(выполнено)*

## Задача: вывод из эксплуатации API Gateway

1. **Анализ зависимости** *(выполнено)*
   - Собрать список файлов и пакетов, которые использует `cmd/api-gateway`.
   - Проверить, кто импортирует общие модули из `internal` и `configs`, чтобы не удалить нужное core.

2. **Определение границ удаления** *(выполнено)*
   - Решить, какие части конфигурации остаются общими, а какие специфичны для API Gateway.
   - Зафиксировать, какие бинарники, docker-артефакты и скрипты больше не нужны.

3. **Пошаговое удаление**
   - Удалить директорию `cmd/api-gateway` и связанные Dockerfile/скрипты. *(выполнено)*
   - Очистить конфиги (`configs/api-gateway.yaml`, `plan.md`, README) от упоминаний сервиса.
   - Проверить зависимости в `go.mod`, удалив неиспользуемые пакеты.

4. **Валидация**
   - Запустить `go build ./cmd/screener-core` для проверки разрыва зависимостей.
   - Обновить план и документацию по итогам.

## Задача: актуализация архитектурной блок-схемы

1. **Новый контекст**
   - Зафиксировать, что API Gateway выведен из эксплуатации.
   - Отразить переход на YAML-конфигурацию в качестве источника списка токенов.

2. **Обновление диаграммы**
   - Переписать существующую блок-схему в формате Mermaid с учётом текущей архитектуры.
   - Визуализировать поток данных: конфиг → загрузка символов → коннекторы → Redis → внешний десктопный клиент.

3. **Документация**
   - Разместить диаграмму в актуальном разделе документации и убедиться, что текст вокруг не ссылается на устаревшие компоненты.

## Задача: переключение CEX-коннекторов на `ticker_source/geckoterminal_pools.json`

1. **Изменение конфигурации**
   - Обновить `configs/screener-core.yaml`, заменив все ссылки на `Temp/all_contracts_merged_reformatted.json` на `ticker_source/geckoterminal_pools.json` для `default_symbols_file` и каждого `symbols_file`.

2. **Запуск и проверка**
   - Запускать стек через основной сценарий, который поднимает Docker и Redis, затем стартует `cmd/screener-core/main.go`.
   - Убедиться по логам, что подписка идёт по тикерам из нового JSON для Gate, Bybit, Bitget и OKX.

3. **Нормализация тикеров GeckoTerminal**
   - Обновить загрузчик `internal/util/symbol_loader.go`, чтобы он извлекал `symbol` из массива `entries` и возвращал базовые тикеры без суффикса.
   - В `cmd/screener-core/main.go` формировать пары `BASE+USDT` перед подпиской для всех CEX.
   - Добавить вспомогательные хелперы/валидацию, чтобы исключать дубли, пустые значения и стабильные монеты.

## Задача: реанимировать `scripts/start_all.sh`

1. **Диагностика**
   - Проверить цепочку запуска: наличие Git Bash, доступность `docker compose`, корректность путей к бинарнику и PID-файлу.
   - Зафиксировать проблему с некорректными PID под Windows и повторными перезапусками.

2. **Доработка скриптов**
   - Модифицировать `scripts/start_all.sh`, чтобы он убивал старый процесс перед запуском, корректно стартовал Redis через Docker и записывал рабочий PID.
   - Обновить `scripts/stop_all.sh`, чтобы корректно завершать процесс под Windows/MSYS: считывать `*.winpid`, проверять процесс через `tasklist` и вызывать `taskkill` как фолбэк, после остановки удалять оба PID-файла.
   - Для всех вызовов `tasklist`/`taskkill` отключать MSYS2 path-conv (через `MSYS2_ARG_CONV_EXCL='*'`), чтобы ключ `/FI` не превращался в путь.

3. **Проверка**
   - Запустить `scripts/start_all.sh --clean-log` и убедиться, что сервис и Redis стартуют, PID валидный, в логах подписки активны.
   - Выполнить `scripts/stop_all.sh --docker-all`, убедиться, что процесс и контейнеры завершаются.
