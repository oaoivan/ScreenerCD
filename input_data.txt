создаем скринер цен cex-dex бирж.
вот общий план:

Общая Архитектура Проекта и Стек Технологий

Название проекта: arbitrage-screener
Основная цель: Высокопроизводительный мониторинг арбитражных возможностей CEX/DEX.
Стек технологий:

    Язык программирования: Go (для всех бэкенд-сервисов)

    База данных/Кэш/Шина сообщений: Redis

    Формат сериализации данных: Protocol Buffers

    Веб-сервер/Прокси: Nginx (для продакшн-развертывания)

    Контейнеризация: Docker, Docker Compose

    Фронтенд: HTML, CSS, JavaScript (с protobuf.js)

Структура Директорий Проекта
code Code
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END

дерево каталогов примерное!    
arbitrage-screener/
├── cmd/
│   ├── screener-core/
│   │   └── main.go           # Точка входа для сервиса Screener Core
│   └── api-gateway/
│       └── main.go           # Точка входа для сервиса API Gateway
├── internal/
│   ├── config/
│   │   └── config.go         # Загрузка и парсинг конфигурации
│   ├── exchange/
│   │   └── connector.go      # Абстракция для подключения к биржам (WS)
│   │   └── bybit.go        # Специфическая реализация для Bybit
│   │   └── kraken.go         # Специфическая реализация для Kraken
│   │   └── uniswap.go        # Специфическая реализация для Uniswap
│   ├── processor/
│   │   └── processor.go      # Логика обработки данных и вычисления дельт
│   ├── redisclient/
│   │   └── client.go         # Обёртка для работы с Redis
│   ├── wsclient/
│   │   └── client.go         # Общая обёртка для WebSocket-клиентов
│   └── util/
│       └── logger.go         # Логирование
│       └── helpers.go        # Общие вспомогательные функции
├── pkg/
│   ├── protobuf/
│   │   ├── arbitrage.proto   # Определение Protobuf сообщений (MarketData, ArbitrageOpportunity)
│   │   └── arbitrage.pb.go   # Сгенерированный Go код
│   └── common/
│       └── models.go         # Общие Go-структуры (если не Protobuf)
├── configs/
│   └── screener-core.yaml    # Конфигурация для Screener Core
│   └── api-gateway.yaml      # Конфигурация для API Gateway
├── web/
│   ├── index.html            # Фронтенд-страница
│   ├── style.css             # Стили для фронтенда
│   ├── app.js                # JavaScript логика фронтенда
│   └── js/
│       └── protobuf_gen.js   # Сгенерированный JS код из arbitrage.proto
│       └── protobuf.min.js   # Библиотека protobuf.js
├── scripts/
│   └── generate_proto.sh     # Скрипт для генерации Protobuf кода
├── Dockerfile.screener-core  # Dockerfile для Screener Core
├── Dockerfile.api-gateway    # Dockerfile для API Gateway
├── docker-compose.yml        # Docker Compose файл
└── README.md

  Сквозной План Разработки (End-to-End)

Поэтапный План Разработки: Высокопроизводительный Криптовалютный Скринер

Цель: Создать единый, отказоустойчивый сервис для автоматического поиска и отображения арбитражных возможностей между CEX и DEX биржами в реальном времени.

Стек: Go, Redis, Protocol Buffers, Docker.

Архитектура: Единый сервис screener, который внутренне разделен на модули. Сбор и обработка данных (Core) и отправка данных клиенту (Gateway) работают как независимые компоненты внутри одного процесса, общаясь через каналы Go.

Шаг 1: Инициализация проекта и получение данных с одной биржи.

    Создать структуру директорий для проекта arbitrage-screener с одним сервисом в cmd/screener.

    Создать файл pkg/protobuf/arbitrage.proto и определить в нем структуру MarketData. Сгенерировать Go-код.

    Реализовать модуль internal/config/config.go для чтения конфигурации из configs/screener.yaml.

    Реализовать модуль-коннектор internal/exchange/bybit.go для подключения, подписки и парсинга данных в структуру MarketData.

    В cmd/screener/main.go реализовать логику:

        Многопоточность: Запустить коннектор для Bybit в отдельной горутине (go ...).

        Основная горутина должна читать из канала MarketData, который возвращает коннектор, и выводить данные в консоль.

    Результат: Рабочее консольное приложение, которое в реальном времени печатает поток цен с Bybit.

Шаг 2: Интеграция с Redis для хранения состояния.

    Реализовать модуль internal/redisclient/client.go для подключения к Redis и выполнения команды HSET.

    В cmd/screener/main.go инициализировать клиент Redis.

    Изменить логику: вместо вывода MarketData в консоль, сохранять каждое обновление в Redis с ключом вида price:{exchange}:{symbol}.

    Результат: Приложение получает данные и сохраняет их в Redis. Работоспособность проверяется через redis-cli.

Шаг 3: Реализация автоматического арбитражного процессора.

    Добавить в pkg/protobuf/arbitrage.proto структуру ArbitrageOpportunity и сгенерировать Go-код.

    Реализовать модули-коннекторы для еще трех бирж (gateio.go, okx.go) и добавить их в конфиг.

    В cmd/screener/main.go реализовать следующую логику:

        Многопоточность (Каналы): Создать один общий, буферизированный канал Go (dataChannel) для MarketData.

        Многопоточность (Сборщики): В цикле запустить горутины-коннекторы для всех бирж из конфига. Все коннекторы должны писать MarketData в общий dataChannel.

        Отказоустойчивость: Запуск каждой горутины-коннектора должен быть обернут в механизм panic recovery, чтобы падение одного коннектора не обрушило все приложение, а только логировало ошибку и пыталось перезапуститься.

    Реализовать основной модуль internal/processor/processor.go и запустить его в отдельной горутине. Его логика:

        Читает MarketData из dataChannel.

        Сохраняет его в Redis.

        В цикле автоматически сравнивает со всеми остальными биржами, читая их цены из Redis.

        При нахождении арбитража, создает ArbitrageOpportunity и выводит его в консоль.

    Результат: Консольное приложение, которое конкурентно слушает 4 биржи и автоматически выводит все найденные арбитражные возможности.

Шаг 4: Интеграция WebSocket-сервера в единый сервис.

    Создать новый модуль internal/gateway/server.go. Его задача — запустить веб-сервер и обслуживать WebSocket-соединение.

    В cmd/screener/main.go:

        Многопоточность (Каналы): Создать второй, буферизированный канал Go (frontendChannel) для ArbitrageOpportunity.

        Многопоточность (Веб-сервер): Запустить gateway.StartServer() в отдельной горутине. Передать в него frontendChannel. Gateway будет читать из этого канала и отправлять данные в WebSocket.

    В internal/processor/processor.go изменить логику: вместо вывода ArbitrageOpportunity в консоль, отправлять его в frontendChannel.

    Создать базовый фронтенд (web/index.html, web/app.js). app.js должен подключаться к WebSocket нашего сервиса screener и выводить десериализованные Protobuf-объекты в консоль браузера.

    Результат: Полностью рабочий сквозной конвейер данных в рамках одного сервиса. Данные с бирж обрабатываются и доставляются в браузер без внешних зависимостей, кроме Redis.

Шаг 5: Визуализация данных и контейнеризация.

    В web/app.js доработать логику: вместо вывода в консоль, динамически создавать и обновлять строки в HTML-таблице.

    Создать один Dockerfile.screener для сборки единого Go-приложения в легковесный образ.

    Создать docker-compose.yml, который одной командой docker-compose up запускает два сервиса: screener и redis.

    Результат: Готовое к развертыванию, простое в поддержке, контейнеризированное приложение, отображающее арбитражные возможности в реальном времени.