создаем скринер цен cex-dex бирж.
вот общий план:

Общая Архитектура Проекта и Стек Технологий

Название проекта: arbitrage-screener
Основная цель: Высокопроизводительный мониторинг арбитражных возможностей CEX/DEX.
Стек технологий:

    Язык программирования: Go (для всех бэкенд-сервисов)

    База данных/Кэш/Шина сообщений: Redis

    Формат сериализации данных: Protocol Buffers

    Веб-сервер/Прокси: Nginx (для продакшн-развертывания)

    Контейнеризация: Docker, Docker Compose

    Фронтенд: HTML, CSS, JavaScript (с protobuf.js)

Структура Директорий Проекта
code Code
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END

    
arbitrage-screener/
├── cmd/
│   ├── screener-core/
│   │   └── main.go           # Точка входа для сервиса Screener Core
│   └── api-gateway/
│       └── main.go           # Точка входа для сервиса API Gateway
├── internal/
│   ├── config/
│   │   └── config.go         # Загрузка и парсинг конфигурации
│   ├── exchange/
│   │   └── connector.go      # Абстракция для подключения к биржам (WS)
│   │   └── bybit.go        # Специфическая реализация для Bybit
│   │   └── kraken.go         # Специфическая реализация для Kraken
│   │   └── uniswap.go        # Специфическая реализация для Uniswap
│   ├── processor/
│   │   └── processor.go      # Логика обработки данных и вычисления дельт
│   ├── redisclient/
│   │   └── client.go         # Обёртка для работы с Redis
│   ├── wsclient/
│   │   └── client.go         # Общая обёртка для WebSocket-клиентов
│   └── util/
│       └── logger.go         # Логирование
│       └── helpers.go        # Общие вспомогательные функции
├── pkg/
│   ├── protobuf/
│   │   ├── arbitrage.proto   # Определение Protobuf сообщений (MarketData, ArbitrageOpportunity)
│   │   └── arbitrage.pb.go   # Сгенерированный Go код
│   └── common/
│       └── models.go         # Общие Go-структуры (если не Protobuf)
├── configs/
│   └── screener-core.yaml    # Конфигурация для Screener Core
│   └── api-gateway.yaml      # Конфигурация для API Gateway
├── web/
│   ├── index.html            # Фронтенд-страница
│   ├── style.css             # Стили для фронтенда
│   ├── app.js                # JavaScript логика фронтенда
│   └── js/
│       └── protobuf_gen.js   # Сгенерированный JS код из arbitrage.proto
│       └── protobuf.min.js   # Библиотека protobuf.js
├── scripts/
│   └── generate_proto.sh     # Скрипт для генерации Protobuf кода
├── Dockerfile.screener-core  # Dockerfile для Screener Core
├── Dockerfile.api-gateway    # Dockerfile для API Gateway
├── docker-compose.yml        # Docker Compose файл
└── README.md

  Сквозной План Разработки (End-to-End)

Поэтапный План Разработки: Высокопроизводительный Криптовалютный Скринер

Цель: Создать систему для автоматического поиска и отображения арбитражных возможностей между CEX и DEX биржами в реальном времени.

Стек: Go, Redis, Protocol Buffers, Docker.

Шаг 1: Инициализация проекта и получение данных с одной биржи.

    Создать структуру директорий проекта arbitrage-screener согласно общепринятым практикам для Go-проектов (/cmd, /internal, /pkg, etc.).

    Создать файл pkg/protobuf/arbitrage.proto и определить в нем структуру MarketData для стандартизированного представления цены с биржи (exchange, symbol, price, timestamp). Сгенерировать Go-код из этого .proto файла.

    Реализовать модуль internal/config/config.go для чтения конфигурации из YAML-файла. Создать configs/screener-core.yaml с параметрами для подключения к одной бирже (например, Bybit).

    Реализовать модуль-коннектор internal/exchange/bybit.go. Он должен подключаться к WebSocket эндпоинту Bybit, подписываться на поток тикеров (например, BTC-USDT), парсить JSON-ответы и преобразовывать их в структуру MarketData.

    В cmd/screener-core/main.go реализовать логику: запустить коннектор для Bybit в отдельной горутине, читать из его канала MarketData и выводить полученные данные в консоль.

    Результат: Рабочее консольное приложение, которое печатает в реальном времени поток цен с Bybit в стандартизированном формате.

Шаг 2: Интеграция с Redis для хранения состояния.

    Реализовать модуль internal/redisclient/client.go для подключения к Redis и выполнения команды HSET.

    В cmd/screener-core/main.go, инициализировать клиент Redis.

    Изменить логику: вместо вывода MarketData в консоль, сохранять каждое обновление в Redis. Использовать HSET с ключом вида price:{exchange}:{symbol} (например, price:bybit:BTC-USDT).

    Результат: Приложение получает данные с биржи и сохраняет их в Redis. Работоспособность проверяется через redis-cli, наблюдая за обновлением хешей в реальном времени.

Шаг 3: Реализация автоматического арбитражного процессора.

    Добавить в pkg/protobuf/arbitrage.proto структуру ArbitrageOpportunity и сгенерировать Go-код.

    Реализовать модули-коннекторы для еще двух бирж: internal/exchange/gateio.go и internal/exchange/okx.go. Добавить их в configs/screener-core.yaml.

    В cmd/screener-core/main.go, реализовать цикл, который запускает горутины-коннекторы для всех бирж, перечисленных в конфигурации. Все коннекторы должны писать MarketData в один общий канал Go.

    Реализовать основной модуль internal/processor/processor.go. Его логика:

        При старте он получает список всех активных бирж из конфигурации.

        При получении MarketData из общего канала (например, bybit:BTC-USDT):

            Сохраняет его в Redis (как на Шаге 2).

            В цикле проходит по всем остальным известным биржам (gateio, okx).

            Для каждой биржи-пары, читает её цену из Redis (HGETALL price:gateio:BTC-USDT).

            Если данные существуют и актуальны, вычисляет процентную дельту.

            Если дельта превышает заданный порог, создает экземпляр ArbitrageOpportunity и выводит его в консоль.

    Результат: Консольное приложение, которое слушает 3 биржи и автоматически выводит в консоль все найденные между ними арбитражные возможности.

Шаг 4: Создание API Gateway для отправки данных на фронтенд.

    В internal/processor/processor.go изменить логику: вместо вывода ArbitrageOpportunity в консоль, сериализовать его в бинарный формат Protobuf и публиковать в Redis Pub/Sub канал arbitrage:updates.

    Создать второй сервис: cmd/api-gateway/main.go.

    Реализовать в API Gateway логику:

        Подключиться к Redis и подписаться на канал arbitrage:updates.

        Создать WebSocket-сервер.

        При получении сообщения из Redis Pub/Sub, транслировать полученный бинарный массив байт всем подключенным WebSocket-клиентам.

    Создать базовый фронтенд: web/index.html и web/app.js.

    В web/app.js, реализовать подключение к API Gateway по WebSocket, настроить прием бинарных данных (arraybuffer) и выводить десериализованные Protobuf-объекты в консоль браузера.

    Результат: Полностью рабочая сквозная система. Данные с бирж обрабатываются Screener Core и через Redis и API Gateway доставляются в браузер, где отображаются в консоли разработчика.

Шаг 5: Визуализация данных и контейнеризация.

    В web/app.js доработать логику: вместо вывода в консоль, динамически создавать и обновлять строки в HTML-таблице на странице index.html. Каждая строка должна соответствовать уникальной арбитражной паре и обновляться без перезагрузки страницы.

    Создать Dockerfile.screener-core и Dockerfile.api-gateway для сборки Go-приложений в легковесные образы.

    Создать docker-compose.yml, который одной командой docker-compose up запускает всю систему: сервис screener-core, сервис api-gateway и сервис redis.

    Результат: Готовое к развертыванию, контейнеризированное приложение, отображающее арбитражные возможности в реальном времени в удобном для пользователя виде.