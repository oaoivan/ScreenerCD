DEX Ingestion — ТЗ «реализация-first»
Дата: 2025-09-23

Подход
— Делаем сразу рабочий минимальный поток и наращиваем функциональность после успешной валидации каждого шага. Никаких «заглушек в вакууме». Этапы атомарные, каждый завершается проверкой производительности и корректности.

Шаг 1. Одна подписка на один пул (WS → событие → лог)
Цель: установить WS к выбранному RPC endpoint сети (например, Ethereum), подписаться на логи конкретного пула (Uniswap V3), стабильно получать события Swap.
Реализация:
- В конфиг добавляем блок dex.enabled и dex.networks[0] с ws_endpoint, chain_id.
- Указываем один pool_address (временно прямо в конфиге: dex.single_pool_address), type=v3, token0/1, decimals0/1, fee.
- Создаём один WS-коннект и выполняем eth_subscribe: logs по адресу пула и топику Swap.
- В цикле читаем сообщения, валидируем поле removed (если есть), логируем сырое событие (info раз в N, debug при флаге).
Критерии успеха:
- Стабильный приём событий Swap без разрывов в течение не менее 5 минут.
- Лог содержит chainId, pool, block/tx, данные Swap.

Шаг 2. Вычисление цены для V3 (sqrtPriceX96)
Цель: парсить событие Swap, извлекать sqrtPriceX96/tick, рассчитывать цену base в quote.
Реализация:
- Декодируем параметры события Swap (без общего ABI-движка — ровно под один пул ради скорости ввода в строй).
- Цена = (sqrtPriceX96^2)/2^192, затем поправка на порядок токенов и decimals.
- Обновляем локальный снапшот цены в памяти; для публикации вводим порог ε (min_delta_bps) и/или min_interval_ms.
Критерии успеха:
- Правильная численная стабильность (сравнить с on-chain калькулятором/референсом в тестовом скрипте).
- Локальная метрика показывает события/сек и среднюю задержку decode < 1мс.

Шаг 3. Запись цены в Redis (per-pool ключ)
Цель: быстро и надёжно писать рассчитанную цену в Redis для пула.
Реализация:
- Ключ: price_pool:<chainId>:<poolAddress> (HSET).
- Поля: price, ts, src=v3, pool, base, quote, base_dec, quote_dec.
- TTL: 10s. Пишем только когда дельта > ε или прошёл min_interval_ms.
- Встроить пайплайнинг на будущее, но сейчас писать единично (прозрачно проверить).
Критерии успеха:
- Ключ обновляется в Redis, значения корректны, задержка WS→Redis ≤ 10–30мс.
- Отсутствуют ошибки Redis при длительном прогоне (≥ 30 минут).

Шаг 4. Сравнение цен (базовая проверка консистентности)
Цель: сравнить DEX-цену с эталоном (например, ценой из CEX или другого пула/оффчейн справочника) — пока offline/опционально.
Реализация:
- Временный компаратор (отдельный скрипт) читает ключ из Redis и сравнивает с ценой из выбранного CEX-коннектора/источника.
- Порог тревоги: |dex - ref| > X bps. Логировать алерты (info) и сохранять статистику расхождений.
Критерии успеха:
- Имеется стабильная картина расхождений, без всплесков из-за ошибок расчёта/decimals.

Шаг 5. Расширение: несколько пулов в одной сети
Цель: обслуживать список пулов (N=10–100) на одном WS с подпиской eth_subscribe: logs.
Реализация:
- Конфиг: dex.pools_file (список пулов v3 к стейблам), отключаем single_pool_address.
- Подписка на массив адресов (если провайдер поддерживает) или по нескольким подпискам/батчам.
- Очередь событий (channel 8k–32k), worker pool decode+price (N=число CPU*2), шардирование по hash(poolAddress).
- Публикация в Redis: включаем батчи (pipeline_size 200–500), публикация по дельте/интервалу.
Критерии успеха:
- Пропускная ≥ целевому N событий/сек без дропов, латентность в пределах.
- Нулевой/минимальный лог ошибок, стабильные reconnect при сбоях.

Шаг 6. AMM V2 поддержка
Цель: добавить поддержку V2-пулов (Sync/Swap) и расчёт цены по резервам.
Реализация:
- Подписки на топик Sync и/или Swap; приоритет Sync для «истинных» резервов.
- Цена = reserveQuote/reserveBase (decimals, порядок токена). Кэшировать decimals/порядок.
- Те же критерии публикации (дельта/интервал), те же ключи Redis (src=v2).
Критерии успеха:
- Корректный расчёт на тестовом пуле, метрики не деградируют.

Шаг 7. Масштабирование и отказоустойчивость
Цель: устойчивость к разрывам и росту числа пулов.
Реализация:
- Reconnect с экспоненциальным backoff, автоматический rebuild подписок.
- Backpressure: при переполнении очереди сэмплировать/объединять редкие публикации.
- Разделение на процессы при необходимости (шардирование пулов по инстансам).
Критерии успеха:
- Долговременный прогон (несколько часов) без утечек и критических ошибок.

Конфигурация (минимально для старта)
В screener-core.yaml добавляем:
  dex:
    enabled: true
    network:
      chain_id: 1
      name: ethereum
      ws_endpoint: wss://…
      resubscribe_backoff_ms: 500
    single_pool_address: 0x…   # Шаг 1–3
    single_pool_type: v3
    single_pool:
      token0: WETH
      token1: USDC
      decimals0: 18
      decimals1: 6
      fee: 500
    pricing:
      filter:
        min_delta_bps: 1
      min_interval_ms: 50
    redis:
      ttl_sec: 10
      pipeline_size: 1   # Шаг 1–3: одиночная запись; позже увеличим
    logging:
      level: info

Схема Redis (старт)
- key: price_pool:<chainId>:<poolAddress>
  fields: price, ts, src, pool, base, quote, base_dec, quote_dec
  TTL: 10s
— Публикация только при дельте > min_delta_bps или раз в min_interval_ms.

Логирование и метрики (старт)
- info: соединение установлено, подписка активна, events/s, latency avg, ошибки Redis/WS.
- debug (по флагу): детали событий, промежуточные расчёты, publish-решения (сэмплинг 1:1000).

Проверки после каждого шага
- Функциональные: наличие событий/цен/ключей в Redis.
- Производительность: events/s, latency WS→Redis, CPU/GC профили ровно при прогоне.
- Надёжность: reconnect сценарии, длительный прогон.

Дальше
- После успешных Шагов 1–3 — переходим к Шагу 5 (мульти-пулы на одной сети), затем V2 (Шаг 6), затем масштабирование (Шаг 7). После стабилизации — сравнение с CEX внутри screener-core и арбитражная логика.

Примечания по скорости
- Избегать лишних аллокаций, использовать большие буферы каналов, кэш decimals/порядка токенов, винить публикации по порогу/интервалу, минимизировать лог в «горячем пути». 
