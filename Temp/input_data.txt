создаем скринер цен cex-dex бирж.
вот общий план:

### Блок-схема (актуальная, Mermaid)

```mermaid
flowchart LR
    Config[screener-core.yaml\n(YAML конфиг)] --> Resolver[Резолвер тикеров\ninline → symbols_file → default]
    Resolver --> Bybit[Коннектор Bybit]
    Resolver --> Gate[Коннектор Gate]
    Resolver --> Bitget[Коннектор Bitget]
    Resolver --> OKX[Коннектор OKX]

    Bybit --> Channel[dataChannel\nобщий буфер]
    Gate --> Channel
    Bitget --> Channel
    OKX --> Channel

    Channel --> Workers[Воркеры Redis\nbatch HSET]
    Workers --> Redis[(Redis)]
    Redis --> Desktop[Десктопный клиент\nчитает price:*]

    Workers --> Logs[Логи и метрики\napp.log]
```

Источник списка тикеров фиксируется в YAML-конфиге: для каждой биржи задаём inline-список или путь к `symbols_file`. Фолбэк — глобальный `default_symbols_file`.

Общая Архитектура Проекта и Стек Технологий

Название проекта: arbitrage-screener
Основная цель: Высокопроизводительный мониторинг арбитражных возможностей CEX/DEX.
Стек технологий:

    Язык программирования: Go (для всех бэкенд-сервисов)

    База данных/Кэш/Шина сообщений: Redis

    Формат сериализации данных: Protocol Buffers

    Веб-сервер/Прокси: Nginx (для продакшн-развертывания)

    Контейнеризация: Docker, Docker Compose

    Фронтенд: HTML, CSS, JavaScript (с protobuf.js)

Структура Директорий Проекта
code Code
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END

дерево каталогов примерное!    
arbitrage-screener/
├── cmd/
│   └── screener-core/
│       └── main.go           # Точка входа для сервиса Screener Core
├── internal/
│   ├── config/
│   │   └── config.go         # Загрузка и парсинг конфигурации
│   ├── exchange/
│   │   ├── connector.go      # Общая абстракция WS-коннекторов
│   │   ├── bybit.go          # Коннектор Bybit
│   │   ├── gateio.go         # Коннектор Gate
│   │   ├── bitget.go         # Коннектор Bitget
│   │   └── okx.go            # Коннектор OKX
│   ├── processor/
│   │   └── processor.go      # Логика обработки/агрегации (стаб)
│   ├── redisclient/
│   │   └── client.go         # Обёртка для работы с Redis
│   └── util/
│       ├── logger.go         # Логирование
│       ├── helpers.go        # Строковые хелперы
│       └── symbol_loader.go  # Чтение списков тикеров
├── pkg/
│   ├── protobuf/
│   │   ├── arbitrage.proto   # Определение Protobuf сообщений
│   │   └── arbitrage.pb.go   # Минимальный Go-стаб
│   └── common/
│       └── models.go         # Общие структуры моделей
├── configs/
│   └── screener-core.yaml    # Конфигурация для Screener Core (YAML)
├── scripts/
│   ├── start_all.sh          # Запуск локально/через Docker
│   ├── stop_all.sh           # Остановка сервисов
│   └── status_all.sh         # Быстрый статус Redis/процесса
├── web/                      # Прототип веб-фронтенда (legacy)
├── plan.md                   # Актуальный план работ
├── Dockerfile.screener-core  # Dockerfile для Screener Core
├── docker-compose.yml        # Docker Compose файл (core + redis)
└── tests/
    └── integration/         # Шаблон для интеграционных тестов

  Сквозной План Разработки (End-to-End)

Поэтапный План Разработки: Высокопроизводительный Криптовалютный Скринер

Цель: Создать единый, отказоустойчивый сервис для автоматического поиска и отображения арбитражных возможностей между CEX и DEX биржами в реальном времени.

Стек: Go, Redis, Protocol Buffers, Docker.

Архитектура: основной сервис `screener-core` забирает рыночные данные с нескольких бирж, складывает их в Redis и логирует метрики. Клиентская часть (десктопное приложение) читает готовые ключи `price:*` напрямую из Redis.

Шаг 1: Инициализация проекта и получение данных с одной биржи.

    Создать структуру директорий для проекта arbitrage-screener с одним сервисом в cmd/screener.

    Создать файл pkg/protobuf/arbitrage.proto и определить в нем структуру MarketData. Сгенерировать Go-код.

    Реализовать модуль internal/config/config.go для чтения конфигурации из configs/screener.yaml.

    Реализовать модуль-коннектор internal/exchange/bybit.go для подключения, подписки и парсинга данных в структуру MarketData.

    В cmd/screener/main.go реализовать логику:

        Многопоточность: Запустить коннектор для Bybit в отдельной горутине (go ...).

        Основная горутина должна читать из канала MarketData, который возвращает коннектор, и выводить данные в консоль.

    Результат: Рабочее консольное приложение, которое в реальном времени печатает поток цен с Bybit.

Шаг 2: Интеграция с Redis для хранения состояния.

    Реализовать модуль internal/redisclient/client.go для подключения к Redis и выполнения команды HSET.

    В cmd/screener/main.go инициализировать клиент Redis.

    Изменить логику: вместо вывода MarketData в консоль, сохранять каждое обновление в Redis с ключом вида price:{exchange}:{symbol}.

    Результат: Приложение получает данные и сохраняет их в Redis. Работоспособность проверяется через redis-cli.

Шаг 3: Реализация автоматического арбитражного процессора.

    Добавить в pkg/protobuf/arbitrage.proto структуру ArbitrageOpportunity и сгенерировать Go-код.

    Реализовать модули-коннекторы для еще трех бирж (gateio.go, okx.go) и добавить их в конфиг.

    В cmd/screener/main.go реализовать следующую логику:

        Многопоточность (Каналы): Создать один общий, буферизированный канал Go (dataChannel) для MarketData.

        Многопоточность (Сборщики): В цикле запустить горутины-коннекторы для всех бирж из конфига. Все коннекторы должны писать MarketData в общий dataChannel.

        Отказоустойчивость: Запуск каждой горутины-коннектора должен быть обернут в механизм panic recovery, чтобы падение одного коннектора не обрушило все приложение, а только логировало ошибку и пыталось перезапуститься.

    Реализовать основной модуль internal/processor/processor.go и запустить его в отдельной горутине. Его логика:

        Читает MarketData из dataChannel.

        Сохраняет его в Redis.

        В цикле автоматически сравнивает со всеми остальными биржами, читая их цены из Redis.

        При нахождении арбитража, создает ArbitrageOpportunity и выводит его в консоль.

    Результат: Консольное приложение, которое конкурентно слушает 4 биржи и автоматически выводит все найденные арбитражные возможности.

Шаг 4: Подготовка данных для десктопного клиента.

    Задокументировать формат ключей Redis (`price:{exchange}:{symbol}`, timestamp/price).

    Реализовать простой CLI-скрипт (или модуль) для чтения последних значений из Redis и сериализации их в удобный для десктопного приложения формат (JSON/Protobuf).

    Обновить README, добавив примеры запросов к Redis и ожидания по частоте обновлений.

    Результат: данные Screener Core можно забирать напрямую из Redis, подключив настольное приложение без промежуточного веб-шлюза.

Шаг 5: Визуализация и контейнеризация.

    При желании использовать прототип `web/` как справочный материал, либо подготовить макет UI в настольном приложении.

    Собрать `Dockerfile.screener-core` и убедиться, что `docker-compose.yml` поднимает только `screener-core` и `redis`.

    Результат: контейнеризированный сервис с документированным интерфейсом данных, готовый к интеграции с десктопным клиентом.